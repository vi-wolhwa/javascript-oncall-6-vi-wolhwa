bb### 미션 해결 전략

#### 1. 본인이 이해하고 구현한 내용에 기반해 '다른 근무자와 순서를 바꿔야 하는 경우'를 자신만의 예시를 들어 설명하세요. (필수)

'다른 근무자와 순서를 바꿔야 하는 경우'에는 다음의 두 가지가 있다.
1. 마지막 평일 -> 첫 공휴일
2. 마지막 공휴일 -> 첫 평일</br>
따라서 `평일 순번 배열`과 `휴일 순번 배열`을 처리하는 공통로직을 함수로 만들면 간략하게 구현할 수 있다.</br>
</br>
또한 이 문제에는 `평일순번, 휴일순번에 각각 1회 편성된다`라는 조건이 있기 때문에 근무 배정은 반드시 성공한다.</br>
</br>
예를 들어 대문자가 평일, 소문자가 휴일이라고 가정하고 다음 상황을 보자. `[A, a, b, A]` 인 상황에서 `A`의 근무가 연속된다. `a`와 `b`의 근무를 변경하면 `[A, b, a, A]`가 된다. 만약 이 상황이 월(month)의 마지막 날에 발생했다면, 마지막 `A`의 근무는 뒷 사람과 교대할 수 없다. 그러나 이 조건 때문에 근무 배정은 반드시 성공한다.</br>

---

#### 2. 요구사항에서 제시한 앞의 날짜부터 순서를 변경하는 방법 외에 다른 방법이 있다면 어떤 방식이 있는지, 이 방법은 기존에 제시된 방식과 비교해 어떤 차이가 있는지 설명하세요. (선택)

앞의 날짜부터 차례대로 연속된 근무가 발생하면 다음 사람과 순서를 변경하는 방법은 근무자의 관점에서 비효율적일 수 있다. 실제 상황에서 하루를 두고 연속해서 비상 근무를 수행하는 것은 실제로 피로할 것이기 때문이다. 따라서 다음의 방법들을 생각해 볼 수 있다.
- 평일 순번을 기준으로, 근무 간 가장 긴 여백기간을 갖도록 휴일 순번을 재정의한다.
이 방법은 최적 적합을 이용하여 구현할 수 있을 것이라고 생각한다. 기존 방법보다 근무자에게 친화적이며, 구현의 난이도 또한 큰 차이가 없다. 단, 가장 효율적인 방법은 아니다.</br>
가장 효율적인 방법에 수렴하는 메소드는 일정 크기의 window 사이즈(모든 근무자가 동일한 횟수만큼 근무하기 위하여 평일, 주말 순번의 공배수가 될 수 있다.)를 정의하고, 해당 window 사이즈에 대하여 A* 알고리즘을 적용하는 것이라고 생각한다 (더 효율적인 탐색 알고리즘이 존재할 수 있다). 휴리스틱 함수는 각 직원의 근무 간격(term)에 가중치를 곱한 후, 모두 더하여 계산할 수 있을 것이다(이렇게 하면 근무 간격이 일정해지도록 유도할 수 있다). 그러나 현실에서 이렇게까지 규칙적으로 배정해야 할 이유가 없기 때문에 휴일 순번만 재정의 하는 방법이 더 효율적이라고 생각한다.
